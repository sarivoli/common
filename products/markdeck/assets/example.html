
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>presentation</title>
    <!-- Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        /* Common Structure */
        /* ===== COMMON STRUCTURE AND LAYOUT ===== */
/* All structural, layout, and non-color styles - NO COLORS HERE */

* { 
    margin: 0; 
    padding: 0; 
    box-sizing: border-box; 
}

body {
    font-family: 'Inter', 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    overflow: hidden;
    width: 100vw;
    height: 100vh;
}

/* ===== BACKGROUND CANVAS ===== */
#bg-canvas { 
    position: absolute; 
    top: 0; 
    left: 0; 
    width: 100%;
    height: 100%;
    z-index: 0; 
}

/* ===== SLIDE CONTAINER ===== */
#slide-container {
    position: relative;
    z-index: 2;
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    transition: opacity 0.5s ease;
}

/* ===== INDIVIDUAL SLIDE ===== */
.slide {
    width: 100%;
    height: 100vh;
    display: none;
    flex-direction: column;
    justify-content: flex-start;
    align-items: center;
    position: absolute;
    top: 0;
    left: 0;
    opacity: 0;
    transition: opacity 0.6s ease-in-out;
}

.slide.active {
    display: flex;
    opacity: 1;
    z-index: 10;
}

/* ===== SLIDE CONTENT CARD ===== */
.slide-content {
    position: relative;
    z-index: 2;
    margin-top: 3em;
    padding: 5px 30px;
    border-radius: 24px;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    width: 95vw;
    height: 85vh;
    overflow-y: auto;
    overflow-x: hidden;
    display: flex;
    flex-direction: column;
    box-shadow: 0 25px 60px rgba(0, 0, 0, 0.35), 0 10px 20px rgba(0, 0, 0, 0.2);
    border: 1px solid;
}

/* ===== GLASS CARD COMPONENT ===== */
.glass-card {
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border-radius: 20px;
    padding: 2.5rem;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.25);
    border: 1px solid;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
}

.glass-card:hover {
    transform: translateY(-4px);
    box-shadow: 0 15px 50px rgba(0, 0, 0, 0.35);
}

/* ===== HEADER GROUP ===== */
.header-group {
    display: block;
    text-align: center;
    margin: 0 auto 40px auto;
    width: fit-content;
    max-width: 100%;
}

.header-group h1 { 
    margin-bottom: 10px; 
}

/* ===== TYPOGRAPHY BASE ===== */
h1 {
    font-size: 3.8rem;
    margin-bottom: 35px;
    font-weight: 800;
    line-height: 1.15;
    letter-spacing: -0.02em;
}

h2 { 
    font-size: 2.2rem; 
    margin-bottom: 25px;
    font-weight: 700;
    line-height: 1.3;
    padding-left: 20px;
}

h3 { 
    font-size: 1.6rem; 
    margin-bottom: 1rem;
    font-weight: 600;
}

h4 { 
    font-size: 1.3rem; 
    margin-bottom: 0.8rem;
    font-weight: 600;
}

h5 { 
    font-size: 1.1rem; 
    margin-bottom: 0.6rem;
    font-weight: 600;
}

p { 
    font-size: 1.15rem; 
    line-height: 1.7; 
    margin-bottom: 1.3rem;
    font-weight: 400;
}

li { 
    font-size: 1.1rem; 
    line-height: 1.7; 
    margin-bottom: 0.6rem; 
}

ul, ol { 
    margin-bottom: 1.8rem; 
    padding-left: 30px; 
}

/* ===== TAGLINE ===== */
.slide-tagline {
    width: 100%;
    font-size: 1.25rem;
    font-weight: 700;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    padding: 15px 0;
    text-align: center;
    margin-top: -10px;
    margin-bottom: 25px;
}

.slide-tagline.has-border {
    border-bottom: 3px solid;
    padding-bottom: 15px;
}

/* ===== HIGHLIGHT SPANS ===== */
.highlight {
    padding: 3px 8px;
    border-radius: 6px;
    font-weight: 600;
    transition: all 0.2s ease;
}

.highlight:hover {
    transform: scale(1.05);
}

/* ===== CODE BLOCKS ===== */
code {
    font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', 'Monaco', monospace;
    font-size: 0.9em;
    padding: 3px 8px;
    border-radius: 6px;
    font-weight: 500;
}

pre {
    padding: 20px;
    border-radius: 12px;
    overflow-x: auto;
    max-width: 100%;
    margin-bottom: 25px;
    white-space: pre-wrap;
    word-break: break-word;
    border: 1px solid;
}

pre code {
    padding: 0;
    white-space: pre-wrap;
}

/* ===== BADGE NOTATION ===== */
.badge {
    display: inline-flex;
    align-items: center;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    font-size: 0.85em;
    line-height: 1;
    border-radius: 6px;
    overflow: hidden;
    margin: 0 5px;
    vertical-align: middle;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
    border: 1px solid;
}

.badge-label {
    padding: 6px 12px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.badge-value {
    padding: 6px 12px;
    font-weight: 700;
}

/* ===== LOGO OVERLAY ===== */
.slide-logo {
    position: absolute;
    top: 20px;
    right: 20px;
    height: 60px;
    opacity: 0.3;
    z-index: 5;
    pointer-events: none;
    object-fit: contain;
}

/* ===== GRID LAYOUTS ===== */
.grid-container {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 30px;
    width: 100%;
    margin: 30px 0;
}

.grid-2 { 
    display: grid; 
    grid-template-columns: 1fr 1fr; 
    gap: 25px; 
}

.grid-3 { 
    display: grid; 
    grid-template-columns: 1fr 1fr 1fr; 
    gap: 25px; 
}

/* ===== WIDGETS ===== */
.slide-widget {
    margin: 30px auto;
    display: flex;
    justify-content: center;
}

/* ===== IMAGES ===== */
img {
    max-width: 100%;
    height: auto;
    border-radius: 12px;
}

.slide-image {
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
    transition: transform 0.3s ease;
}

.slide-image:hover {
    transform: scale(1.02);
}

/* ===== NAVIGATION BAR ===== */
.nav-bar {
    position: fixed;
    bottom: 40px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    align-items: center;
    gap: 25px;
    z-index: 100;
    padding: 15px 30px;
    border-radius: 50px;
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    opacity: 0;
    transition: opacity 0.4s ease, transform 0.3s ease;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    border: 1px solid;
}

.nav-bar:hover, 
.nav-bar.visible { 
    opacity: 1;
    transform: translateX(-50%) translateY(-5px);
}

/* ===== STATUS BAR ===== */
.status-bar {
    position: fixed;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 0.95rem;
    padding: 8px 20px;
    border-radius: 20px;
    z-index: 90;
    pointer-events: none;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    transition: opacity 0.3s;
    font-weight: 500;
}

/* ===== NAVIGATION BUTTONS ===== */
.btn-nav {
    background: none;
    border: 2px solid;
    font-size: 1.05rem;
    cursor: pointer;
    padding: 10px 20px;
    border-radius: 25px;
    transition: all 0.3s ease;
    font-weight: 600;
    letter-spacing: 0.5px;
}

.btn-nav:hover {
    transform: scale(1.05);
}

.btn-nav:active {
    transform: scale(0.95);
}

/* ===== PROGRESS BAR ===== */
.progress-track {
    width: 250px;
    height: 8px;
    border-radius: 10px;
    align-self: center;
    overflow: hidden;
    box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
}

.progress-fill {
    height: 100%;
    width: 0%;
    transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    border-radius: 10px;
}

/* ===== NO BORDER CARD ===== */
.glass-card.no-border {
    background: transparent !important;
    border: none !important;
    box-shadow: none !important;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
    padding: 5px;
}

.glass-card.no-border:hover {
    transform: none;
    box-shadow: none !important;
}
/* ===== ANIMATIONS ===== */
@keyframes slideUp {
    from { 
        opacity: 0; 
        transform: translateY(50px) scale(0.96); 
    }
    to { 
        opacity: 1; 
        transform: translateY(0) scale(1); 
    }
}

@keyframes fadeInUp {
    from { 
        opacity: 0; 
        transform: translateY(30px); 
    }
    to { 
        opacity: 1; 
        transform: translateY(0); 
    }
}

@keyframes float {
    0%, 100% { transform: translateY(0) rotate(0deg); }
    50% { transform: translateY(-10px) rotate(5deg); }
}

@keyframes glow {
    0%, 100% { filter: brightness(1); }
    50% { filter: brightness(1.2); }
}

/* ===== SCROLLBAR ===== */
::-webkit-scrollbar { 
    width: 10px; 
}

::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.1);
    border-radius: 10px;
}

::-webkit-scrollbar-thumb {
    background: rgba(0, 0, 0, 0.3);
    border-radius: 10px;
}

::-webkit-scrollbar-thumb:hover {
    background: rgba(0, 0, 0, 0.5);
}

/* ===== TABLES ===== */
table {
    width: 100%;
    border-collapse: collapse;
    font-family: inherit;
    margin: 25px 0;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

th, td {
    padding: 14px 18px;
    text-align: left;
    border-bottom: 1px solid;
}

table thead th {
    font-weight: 700;
    position: sticky;
    top: 0;
    z-index: 1;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    font-size: 0.9rem;
}

table tbody tr {
    transition: all 0.2s ease;
}

table tbody td:first-child {
    font-weight: 600;
}

/* ===== RESPONSIVE ===== */
@media (max-width: 1024px) {
    h1 { font-size: 3rem; }
    h2 { font-size: 1.9rem; }
    .slide-content { padding: 30px 35px; width: 97vw; }
}

@media (max-width: 768px) {
    h1 { font-size: 2.5rem; }
    h2 { font-size: 1.6rem; }
    .slide-content { padding: 25px 25px; width: 98vw; }
    .nav-bar { gap: 15px; padding: 12px 20px; }
    .progress-track { width: 150px; }
}
        
        /* Widget Styles */
        /* Alert Blocks (Quote, Info, Warning) */
.alert {
    padding: 20px;
    margin: 20px 0;
    border-radius: 8px;
    border-left: 5px solid;
    font-size: 16px;
    line-height: 1.6;
}

.alert-quote {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-left-color: #4c51bf;
    color: white;
    font-style: italic;
    position: relative;
}

.alert-quote::before {
    content: '"';
    font-size: 60px;
    position: absolute;
    top: -10px;
    left: 10px;
    opacity: 0.3;
}

.alert-info {
    background: linear-gradient(135deg, #89f7fe 0%, #66a6ff 100%);
    border-left-color: #3182ce;
    color: #1a365d;
}

.alert-warning {
    background: linear-gradient(135deg, #f6d365 0%, #fda085 100%);
    border-left-color: #dd6b20;
    color: #7c2d12;
}

/* CountUp/CountDown Widgets */
.countup-widget,
.countdown-widget {
    display: inline-block;
    font-size: 48px;
    font-weight: bold;
    color: #ffffff;
    padding: 10px 20px;
    background: #fff306;
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
}

/* Meter Widget (Speedometer Style) */
.meter-widget {
    position: relative;
    margin: 30px auto;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}

.meter-display {
    font-size: 48px;
    font-weight: bold;
    margin-bottom: 20px;
    color: #ffffff;
}

.meter-gauge {
    width: 100%;
    height: 50%;
    position: relative;
    overflow: hidden;
}

.meter-bar {
    position: absolute;
    bottom: 0;
    height: 30px;
    transition: all 0.3s ease;
}

.meter-bar.red { background: #f56565; left: 0; }
.meter-bar.yellow { background: #ecc94b; }
.meter-bar.green { background: #48bb78; }

.meter-needle {
    position: absolute;
    bottom: 15px;
    left: 50%;
    width: 4px;
    height: 40%;
    background: #aecafb;
    transform-origin: bottom center;
    transition: transform 2s cubic-bezier(0.45, 0, 0.55, 1);
    border-radius: 2px;
}

.meter-needle::after {
    content: '';
    position: absolute;
    bottom: -8px;
    left: 50%;
    transform: translateX(-50%);
    width: 16px;
    height: 16px;
    background: #9fbef4;
    border-radius: 50%;
}

.meter-labels {
    display: flex;
    justify-content: space-between;
    width: 100%;
    margin-top: 10px;
    font-size: 14px;
    color: #ffffff;
}

/* Progress Bar Widget */
.progress-widget {
    margin: 20px auto;
    padding: 10px;
}

.progress-label {
    text-align: center;
    font-size: 24px;
    font-weight: bold;
    margin-bottom: 10px;
    color: #ffffff;
}

.progress-bar-container {
    width: 100%;
    height: 100%;
    background: #e2e8f0;
    border-radius: 25px;
    overflow: hidden;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
    position: relative;
}

.progress-bar-fill {
    height: 100%;
    width: 0%;
    border-radius: 25px;
    transition: width 2s cubic-bezier(0.45, 0, 0.55, 1);
    background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
    box-shadow: 0 2px 10px rgba(102, 126, 234, 0.5);
    position: relative;
    overflow: hidden;
}

.progress-bar-fill::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(
        90deg,
        transparent,
        rgba(255, 255, 255, 0.3),
        transparent
    );
    animation: shimmer 2s infinite;
}



@keyframes shimmer {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
}

.progress-bar-fill.blue { background: linear-gradient(90deg, #4299e1 0%, #3182ce 100%); }
.progress-bar-fill.green { background: linear-gradient(90deg, #48bb78 0%, #38a169 100%); }
.progress-bar-fill.red { background: linear-gradient(90deg, #f56565 0%, #e53e3e 100%); }
.progress-bar-fill.yellow { background: linear-gradient(90deg, #ecc94b 0%, #d69e2e 100%); }
.progress-bar-fill.purple { background: linear-gradient(90deg, #9f7aea 0%, #805ad5 100%); }

/* Polaroid Image */
.polaroid-image {
    display: inline-block;
    background: white;
    padding: 15px 15px 60px 15px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3), 0 1px 3px rgba(0,0,0,0.1);
    margin: 20px;
    transform: rotate(-2deg);
    transition: all 0.3s ease;
    max-width: 400px;
}

.polaroid-image:hover {
    transform: rotate(0deg) scale(1.05);
    box-shadow: 0 15px 40px rgba(0,0,0,0.4);
}

.polaroid-image a {
    display: block;
    text-decoration: none;
    cursor: pointer;
}

.polaroid-image a:hover img {
    opacity: 0.9;
    transition: opacity 0.3s ease;
}

.polaroid-image img {
    width: 100%;
    height: auto;
    display: block;
    border: 1px solid #ddd;
    transition: opacity 0.3s ease;
}

.polaroid-caption {
    margin-top: 15px;
    padding-top: 15px;
    text-align: center;
    font-family: 'Courier New', monospace;
    font-size: 18px;
    color: #2d3748;
    border-top: 1px solid #e2e8f0;
    font-weight: 500;
}

/* Make it clear the image is clickable when link is present */
.polaroid-image a img {
    cursor: pointer;
}

.polaroid-image a:hover {
    opacity: 1;
}

/* Flip Card */
.flip-card {
    background-color: transparent;
    width: 100%;
    min-height: 300px;
    perspective: 1000px;
    margin: 20px 0;
    cursor: pointer;
    flex: 1; /* Allow flex in grids */
    min-width: 200px; /* Minimum width in grids */
}

.flip-card-inner {
     position: relative;
    width: 100%;
    height: 100%;
    min-height: inherit; /* Inherit min-height from parent */
    text-align: center;
    transition: transform 0.8s;
    transform-style: preserve-3d;
}

.flip-card.flipped .flip-card-inner {
    transform: rotateY(180deg);
}

.flip-card-front,
.flip-card-back {
     position: absolute;
    width: 100%;
    height: 100%;
    min-height: inherit; /* Inherit min-height */
    backface-visibility: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 30px;
    border-radius: 15px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.2);
}

.flip-card-front {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    font-weight: bold;
    text-align: center;
}

.flip-card-back {
    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    color: white;
    transform: rotateY(180deg);
    overflow-y: auto;
}

.flip-card-back h1,
.flip-card-back h2,
.flip-card-back h3,
.flip-card-back h4 {
    color: white;
    margin-top: 0;
}

/* Grid Container with Flex Support */
.grid-container {
    display: flex;
    gap: 20px;
    flex-wrap: wrap;
    margin: 20px 0;
}

/* If grid has explicit columns, use grid layout */
.grid-container[style*="grid-template-columns"] {
    display: grid;
}

/* Glass Card with Flex Support */
.glass-card {
    flex: 1;
    min-width: 200px;
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .countup-widget,
    .countdown-widget {
        font-size: 32px;
    }
    
    .meter-widget {
        
        width: 100% !important;
    }
    
    .progress-widget {
        width: 100% !important;
    }
    
    .polaroid-image {
        max-width: 100%;
    }
    
    .flip-card-front {
        font-size: 24px !important;
    }
    
    .grid-container {
        flex-direction: column;
    }
}

/* Make widgets appear clickable */
.meter-widget,
.progress-widget,
.countup-widget,
.countdown-widget {
    cursor: pointer;
    transition: transform 0.2s ease;
}

.meter-widget:hover,
.progress-widget:hover {
    transform: scale(1.02);
}

.countup-widget:hover,
.countdown-widget:hover {
    transform: scale(1.1);
}

.meter-widget:active,
.progress-widget:active,
.countup-widget:active,
.countdown-widget:active {
    transform: scale(0.98);
}
        
        /* Theme Overrides & Colors */
        /* ===== NEON NIGHTS THEME ===== */
:root {
    --bg-dark: #1a1a2e;
    --bg-secondary: #16213e;
    --primary: #0f3460;
    --accent-cyan: #00f5ff;
    --accent-magenta: #ff2079;
    --accent-yellow: #ffea00;
    --text: #e4e4e4;
    --text-glow: #ffffff;
    --glass: rgba(15, 52, 96, 0.7);
    --glass-border: rgba(0, 245, 255, 0.4);
    --card-bg: rgba(22, 33, 62, 0.8);
}

body {
    background: radial-gradient(circle at top right, var(--bg-secondary), var(--bg-dark));
    color: var(--text);
}

body::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: 
        radial-gradient(circle at 20% 50%, rgba(0, 245, 255, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 80% 80%, rgba(255, 32, 121, 0.1) 0%, transparent 50%);
    pointer-events: none;
    z-index: 1;
}

.slide-content {
    background: var(--glass);
    border-color: var(--glass-border);
    box-shadow: 
        0 0 40px rgba(0, 245, 255, 0.2),
        0 25px 60px rgba(0, 0, 0, 0.4);
}

.glass-card {
    background: var(--card-bg);
    border-color: var(--accent-cyan);
    border-left: 4px solid var(--accent-magenta);
    box-shadow: 
        0 0 25px rgba(0, 245, 255, 0.15),
        0 10px 40px rgba(0, 0, 0, 0.3);
}

h1 {
    background: linear-gradient(120deg, var(--accent-cyan), var(--accent-magenta), var(--accent-yellow));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    filter: drop-shadow(0 0 25px rgba(0, 245, 255, 0.7));
    animation: glow 3s ease-in-out infinite;
}

h2 { 
    color: var(--accent-cyan);
    border-left-color: var(--accent-magenta);
    text-shadow: 0 0 15px rgba(0, 245, 255, 0.5);
}

h3, h4, h5 { 
    color: var(--text);
    text-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
}

.slide-tagline {
    color: var(--accent-magenta);
    text-shadow: 0 0 15px rgba(255, 32, 121, 0.7);
}

.slide-tagline.has-border {
    border-bottom-color: var(--accent-cyan);
}

.highlight {
    background: #ffea00;
    color: #000000;
    box-shadow: 0 0 20px rgba(243, 16, 0, 0.642);
}

code {
    background: rgba(0, 245, 255, 0.1);
    color: var(--accent-cyan);
    border: 1px solid var(--glass-border);
}

pre {
    background: rgba(0, 0, 0, 0.5);
    border-color: var(--accent-cyan);
}

.badge {
    border-color: var(--accent-cyan);
    box-shadow: 0 0 15px rgba(0, 245, 255, 0.3);
}

.badge-label {
    background: var(--bg-dark);
    color: var(--accent-cyan);
}

.badge-value {
    background: linear-gradient(120deg, var(--accent-cyan), var(--accent-magenta));
    color: #fff;
}

.nav-bar {
    background: rgba(26, 26, 46, 0.9);
    border-color: var(--accent-cyan);
    box-shadow: 0 0 30px rgba(0, 245, 255, 0.3);
}

.btn-nav {
    background: rgba(0, 245, 255, 0.1);
    border-color: var(--accent-cyan);
    color: var(--text-glow);
}

.btn-nav:hover {
    background: var(--accent-cyan);
    color: var(--bg-dark);
    box-shadow: 0 0 25px rgba(0, 245, 255, 0.7);
}

.status-bar {
    color: var(--text);
    background: rgba(0, 0, 0, 0.6);
}

.progress-fill {
    background: linear-gradient(90deg, var(--accent-cyan), var(--accent-magenta), var(--accent-yellow));
    box-shadow: 0 0 20px rgba(0, 245, 255, 0.7);
}

table thead th {
    background: linear-gradient(135deg, var(--primary), var(--bg-dark));
    color: var(--accent-cyan);
}

table tbody tr:hover {
    background: rgba(0, 245, 255, 0.1);
}
        
        /* Conditional Overrides */
        
        
        /* Fixed Logo Styles */
        .slide-logo-fixed {
            position: fixed;
            bottom: 20px;
            left: 20px;
            max-width: 120px;
            max-height: 80px;
            z-index: 1000;
            opacity: 0.9;
            transition: opacity 0.3s ease;
        }
        
        .slide-logo-fixed:hover {
            opacity: 1;
        }
        
        /* Progress bar initial state fix */
        .progress-fill {
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <!-- Background Canvas -->
    <canvas id="bg-canvas" style="position: absolute; top:0; left:0; width:100%; height:100%; z-index:0;"></canvas>

    <!-- Fixed Logo -->
    <img src="https://github.com/sarivoli/common/blob/8c31a8aeb9a5cba214fa94c8fdaec86e5eb2636f/arivoli-in-logo.png?raw=true" class="slide-logo-fixed" alt="Logo">

    <div id="slide-container">
        
            <div class="slide" id="slide-0" data-transition="ease">
                <div class="slide-content">
                    <div class="header-group"><h1>MARKDECK</h1><div class="slide-tagline has-border" style="text-align: center;">MARKDOWN + SLIDE DECK</div></div>
<div class="grid-container" style="grid-template-columns: repeat(3, 1fr);"><div class="glass-card" style="position: relative; overflow: hidden;"><h3>Standard Markdown</h3>
<ul>
<li>Headings (H1, H2, H3)</li>
<li><strong>Bold</strong> and <em>italic</em> text</li>
<li>Ordered and unordered lists</li>
<li>Paragraphs and line breaks</li>
<li>Image tag</li>
<li>Tables</li>
<li><input checked="" disabled="" type="checkbox"> Completed Task</li>
<li><input disabled="" type="checkbox"> Open Task</li>
</ul>
</div>
  <div class="glass-card" style="position: relative; overflow: hidden;"><h3>Custom Notations</h3>
<ul>
<li><span class="highlight">@highlight for emphasis</span></li>
<li><code>@card</code> for content cards</li>
<li><code>@grids</code> for layout</li>
<li><code>@widgets</code> for charts with dimensions</li>
<li><code>@slide</code> with transitions (ease, fade, slide, zoom)</li>
</ul>
</div>
  <div class="glass-card" style="position: relative; overflow: hidden;"><h3>Metadata Options</h3>
<ul>
<li><code>@type</code> - presentation type</li>
<li><code>@theme</code> - theme selection</li>
<li><code>@logo</code> - logo URL</li>
<li><code>@background</code> - background configuration</li>
<li>Supporting <code>width</code> and <code>height</code> for images</li>
</ul>
</div></div>
                </div>
            </div>
        

            <div class="slide" id="slide-1" data-transition="fade">
                <div class="slide-content">
                    <h2>Lists &amp; Headings</h2>
<div class="grid-container" style="grid-template-columns: repeat(3, 1fr);"><div class="glass-card" style="position: relative; overflow: hidden;"><h3>Unordered Lists:</h3>
<ul>
<li>First item</li>
<li>Second item</li>
<li>Third item</li>
</ul>
<h3>Ordered Lists:</h3>
<ol>
<li>First step</li>
<li>Second step</li>
<li>Third step</li>
</ol>
</div>
<div class="glass-card" style="position: relative; overflow: hidden;"><h3>Headings:</h3>
<h1>H1</h1>
<h2>H2</h2>
<h3>H3</h3>
<h4>H4</h4>
<h5>H5</h5>
<h6>H6</h6>
</div>

<div class="glass-card" data-animation="growth" style="position: relative; overflow: hidden;"><canvas class="card-bg-canvas" style="position:absolute; top:0; left:0; width:100%; height:100%; z-index:-1; border-radius:inherit;"></canvas><h3>Code &amp; Pre Code</h3>
<p>Pre Code: <code>Pre code </code></p>
<pre><code>&lt;div class=&quot;glass-card&quot; style=&quot;height: 400px; display: flex; justify-content: center;&quot;&gt;
            &lt;canvas id=&quot;teamChart&quot;&gt;&lt;/canvas&gt;
        &lt;/div&gt;
</code></pre>
</div></div>
                </div>
            </div>
        

            <div class="slide" id="slide-2" data-transition="slide">
                <div class="slide-content">
                    <h2>Cards, Grids, Animation &amp; Themes</h2>
<div class="grid-container"><div class="glass-card" data-animation="security" style="position: relative; overflow: hidden;"><canvas class="card-bg-canvas" style="position:absolute; top:0; left:0; width:100%; height:100%; z-index:-1; border-radius:inherit;"></canvas><p><span class="highlight">MarkDeck comes with professionally curated themes</span></p>
<ul>
<li><code>OceanBlue</code> (Default)</li>
<li><code>CyberNeon</code> (Dark/Cyan/Pink)</li>
<li><code>CoralReef</code> (Nature Wellness)</li>
<li><code>TropicalSunset</code> (Warm)</li>
<li><code>ElectricViolet</code> (Creative)</li>
<li><code>IndustrialChic</code> (Corporate)</li>
<li><code>AutumnHarvest</code> (Warm/Cozy)</li>
<li><code>NeonNights</code> (High Contrast)</li>
</ul>
<p>This card is configured with <span class="badge"><span class="badge-label">animation</span><span class="badge-value">security</span></span></p>
</div>

<div class="glass-card" data-animation="transform" style="position: relative; overflow: hidden;"><canvas class="card-bg-canvas" style="position:absolute; top:0; left:0; width:100%; height:100%; z-index:-1; border-radius:inherit;"></canvas><p><span class="highlight">5 themed animations designed for specific presentation topics</span></p>
<ul>
<li><code>net</code> - Particle network with connections</li>
<li><code>security</code> - Binary code rain with shields</li>
<li><code>transform</code> - Morphing shapes with color transitions</li>
<li><code>growth</code> - Upward arrows with currency symbols</li>
<li><code>celebrate</code> - Confetti with sparkles</li>
<li><code>initiative</code> - Forward arrows with progress waves</li>
</ul>
<p>This card is configured with <span class="badge"><span class="badge-label">animation</span><span class="badge-value">transform</span></span></p>
</div></div>
                </div>
            </div>
        

            <div class="slide" id="slide-3" data-transition="zoom">
                <div class="slide-content">
                    <h2>Data Visualization</h2>
<div class="grid-container" style="grid-template-columns: repeat(3, 1fr);"><div class="glass-card" data-animation="celebrate" style="position: relative; overflow: hidden;"><canvas class="card-bg-canvas" style="position:absolute; top:0; left:0; width:100%; height:100%; z-index:-1; border-radius:inherit;"></canvas><h3>Bar Chart</h3>
<div class="slide-widget" data-config='{
  "title": "Quarterly Sales",
  "type": "bar",
  "width": 300,
  "height": 300,
  "data": {
    "labels": ["Q1", "Q2", "Q3", "Q4"],
    "datasets": [{
        "label": "2024 Sales",
        "data": [12, 19, 15, 25],
        "backgroundColor": "rgba(52, 216, 134, 1)"
    }]
  }
}' data-width="300" data-height="300"></div></div>

<div class="glass-card" data-animation="growth" style="position: relative; overflow: hidden;"><canvas class="card-bg-canvas" style="position:absolute; top:0; left:0; width:100%; height:100%; z-index:-1; border-radius:inherit;"></canvas><h3>Table</h3>
<table>
<thead>
<tr>
<th>Tool</th>
<th>Type</th>
</tr>
</thead>
<tbody><tr>
<td>Ticket360</td>
<td>Browser Extension</td>
</tr>
<tr>
<td>NoteWithVS</td>
<td>Visual Studio Extension</td>
</tr>
<tr>
<td>MARKDECK</td>
<td>Visual Studio Extension</td>
</tr>
</tbody></table>
</div>

<div class="glass-card" data-animation="initiative" style="position: relative; overflow: hidden;"><canvas class="card-bg-canvas" style="position:absolute; top:0; left:0; width:100%; height:100%; z-index:-1; border-radius:inherit;"></canvas><h3>Line Chart</h3>
<div class="slide-widget" data-config='{
  "title": "New Sales",
  "type": "line",
  "width": 300,
  "height": 300,
  "data": {
    "labels": ["Q1", "Q2", "Q3", "Q4"],
    "datasets": [{
        "label": "2024 Sales",
        "data": [12, 19, 15, 25],
        "backgroundColor": "rgba(52, 216, 134, 1)"
    }]
  }
}' data-width="300" data-height="300"></div></div></div>
                </div>
            </div>
        

            <div class="slide" id="slide-4" data-transition="fade">
                <div class="slide-content">
                    <h1>Grid with Flex Ratios</h1>
<div class="grid-container" style="grid-template-columns: repeat(3, 1fr);"><div class="glass-card" style="flex: 2; position: relative; overflow: hidden;"><h3>Major Card (2x width)</h3>
<p>This card takes up twice the space of the others because of <code>flex=&quot;2&quot;</code>.</p>
<p><strong>Key Features:</strong></p>
<ul>
<li>Double width</li>
<li>More content space</li>
<li>Better visibility</li>
</ul>
</div>

<div class="glass-card" style="flex: 1; position: relative; overflow: hidden;"><h3>Normal Card</h3>
<p>Standard width card with <code>flex=&quot;1&quot;</code>.</p>
</div>

<div class="glass-card" style="flex: 1; position: relative; overflow: hidden;"><h3>Another Normal</h3>
<p>Another standard card.</p>
</div></div>
                </div>
            </div>
        

            <div class="slide" id="slide-5" data-transition="fade">
                <div class="slide-content">
                    <h1>Percentage-Based Grid Layout</h1>
<div class="grid-container"><div class="glass-card" style="flex: 7; position: relative; overflow: hidden;"><h3>Main Content (70%)</h3>
<p>This card occupies 70% of the row width.</p>
</div>

<div class="glass-card" style="flex: 3; position: relative; overflow: hidden;"><h3>Sidebar (30%)</h3>
<p>This sidebar takes 30% of the space.</p>
<p><strong>Quick Links:</strong></p>
<ul>
<li>Dashboard</li>
<li>Settings</li>
<li>Help</li>
</ul>
</div></div>
                </div>
            </div>
        

            <div class="slide" id="slide-6" data-transition="fade">
                <div class="slide-content">
                    <h1>Complex Layout with Multiple Ratios</h1>
<div class="grid-container"><div class="glass-card" style="flex: 1; position: relative; overflow: hidden;"><h3>Card 1</h3>
<p>25% width</p>
</div>

<div class="glass-card" style="flex: 2; position: relative; overflow: hidden;"><h3>Card 2 (Featured)</h3>
<p>50% width - Featured content</p>
</div>

<div class="glass-card" style="flex: 1; position: relative; overflow: hidden;"><h3>Card 3</h3>
<p>25% width</p>
</div></div>

<div class="grid-container"><div class="glass-card" style="flex: 3; position: relative; overflow: hidden;"><h3>Large Card</h3>
<p>Takes 75% of the space</p>
<p>More content here with plenty of room to breathe.</p>
</div>

<div class="glass-card" style="flex: 1; position: relative; overflow: hidden;"><h3>Small</h3>
<p>25%</p>
</div></div>
                </div>
            </div>
        

            <div class="slide" id="slide-7" data-transition="fade">
                <div class="slide-content">
                    <h1>Quote, Info &amp; Warning Blocks</h1>
<!-- @quote -->
<p>&quot;The only way to do great work is to love what you do.&quot; - Steve Jobs</p>
<!-- @endquote -->

<!-- @info -->
<p>üí° <strong>Pro Tip</strong>: Use keyboard arrows or click buttons to navigate slides</p>
<!-- @endinfo -->

<!-- @warning -->
<p>‚ö†Ô∏è <strong>Important</strong>: Make sure to save your work frequently!</p>
<!-- @endwarning -->
                </div>
            </div>
        

            <div class="slide" id="slide-8" data-transition="fade">
                <div class="slide-content">
                    <h1>CountUp &amp; CountDown Widgets</h1>
<h2>Revenue Growth</h2>
<p>We achieved <span class="countup-widget" data-target="150" data-prefix="$" data-suffix="M" data-duration="2000" style="text-align: left"></span> in revenue this quarter!</p>
<h2>Days Until Launch</h2>
<p>Only <span class="countdown-widget" data-target="7" data-start="30" data-prefix="" data-suffix=" days" data-duration="2000" style="text-align: left"></span> remaining until our product launch!</p>
<h2>Customer Satisfaction</h2>
<p>Our satisfaction score is <span class="countup-widget" data-target="98" data-prefix="" data-suffix="%" data-duration="3000" style="text-align: left"></span></p>

                </div>
            </div>
        

            <div class="slide" id="slide-9" data-transition="fade">
                <div class="slide-content">
                    <h1>Meter Widget (Speedometer Style)</h1>
<h2>Performance Metrics</h2>
<div class="meter-widget" data-target="85" data-green="70" data-yellow="50" data-red="30" style="width:400px; height:250px;"></div>

<p>Our system is performing at <span class="highlight">85%</span> efficiency!</p>

                </div>
            </div>
        

            <div class="slide" id="slide-10" data-transition="fade">
                <div class="slide-content">
                    <h1>Progress Bar Widgets</h1>
<h2>Project Completion</h2>
<div class="progress-widget" data-target="75" data-color="green" data-prefix="" data-suffix="" data-ratio="false" style="width:500px; height:50px;"></div>

<h2>Budget Utilization</h2>
<div class="progress-widget" data-target="60" data-color="blue" data-prefix="$" data-suffix="M" data-ratio="true" style="width:500px; height:50px;"></div>

<h2>Team Productivity</h2>
<div class="progress-widget" data-target="90" data-color="purple" data-prefix="" data-suffix="" data-ratio="false" style="width:500px; height:50px;"></div>
                </div>
            </div>
        

            <div class="slide" id="slide-11" data-transition="fade">
                <div class="slide-content">
                    <h1>Flip Cards - Interactive Content</h1>
<div class="flip-card" data-auto="false" data-count="3" data-delay="2000">
            <div class="flip-card-inner">
                <div class="flip-card-front" style="font-size:76px;">Big Message</div>
                <div class="flip-card-back"><p>This is the back of the card with non auto flip mode enabled</p>
</div>
            </div>
        </div>

<div class="grid-container"><div class="flip-card" data-auto="true" data-count="3" data-delay="2000">
            <div class="flip-card-inner">
                <div class="flip-card-front" style="font-size:24px;">Card with Auto flip enabled</div>
                <div class="flip-card-back"><p>This card is getting flipped automatically</p>
</div>
            </div>
        </div>

<div class="flip-card" data-auto="false" data-count="3" data-delay="2000">
            <div class="flip-card-inner">
                <div class="flip-card-front" style="font-size:24px;">Normal Card</div>
                <div class="flip-card-back"><p><span data-ph="highlight-0"></span></p>
</div>
            </div>
        </div></div>
                </div>
            </div>
        

            <div class="slide" id="slide-12" data-transition="fade">
                <div class="slide-content">
                    <h1>Combining Multiple Features</h1>
<h2>Performance Dashboard</h2>
<div class="grid-container" style="grid-template-columns: repeat(2, 1fr);"><div class="glass-card" data-animation="waves" data-colors='{"primary":"#667eea","secondary":"#764ba2"}' style="position: relative; overflow: hidden;"><canvas class="card-bg-canvas" style="position:absolute; top:0; left:0; width:100%; height:100%; z-index:-1; border-radius:inherit;"></canvas><h3>Quarterly Revenue</h3>
<p><span class="countup-widget" data-target="250" data-prefix="$" data-suffix="M" data-duration="2000" style="text-align: left"></span></p>
<p>Revenue target exceeded by <span class="highlight">15%</span>!</p>
</div>

<div class="glass-card" style="position: relative; overflow: hidden;"><h3>Customer Growth</h3>
<div class="progress-widget" data-target="85" data-color="green" data-prefix="" data-suffix="" data-ratio="false" style="width:300px; height:40px;"></div></div></div>

<div class="meter-widget" data-target="92" data-green="80" data-yellow="60" data-red="40" style="width:500px; height:400px;"></div>
                </div>
            </div>
        

            <div class="slide" id="slide-13" data-transition="ease">
                <div class="slide-content">
                    <h2>More Tools from <span class="badge"><span class="badge-label">Author</span><span class="badge-value">Arivoli</span></span> !</h2>
<div class="grid-container"><div class="glass-card" style="position: relative; overflow: hidden;"><h3><span class="highlight">NoteWithVs</span></h3>
<div class="polaroid-image" style="text-align:center;">
            <a href="https://marketplace.visualstudio.com/items?itemName=arivoli-in.notewithvs" target="_blank" rel="noopener noreferrer"><img src="https://raw.githubusercontent.com/sarivoli/common/e361a062a0b0282027c5bd85107c33ba513340d1/notewithvs/logo.png" alt="NoteWithVS"></a>
            <div class="polaroid-caption">Visual Studio Extension</div>
        </div></div>
<div class="glass-card" style="position: relative; overflow: hidden;"><h3><span class="highlight">Ticket360</span></h3>
<div class="polaroid-image" style="text-align:center;">
            <a href="https://chromewebstore.google.com/detail/ticket360/ebmjdbakddbnbjjfhonhobicbdjhoobd?utm_source=item-share-cb" target="_blank" rel="noopener noreferrer"><img src="https://github.com/sarivoli/common/blob/613558716d0ee7094aca3fa97499bdbc5fcc4298/Ticket360/ticket360.png?raw=true" alt="Ticket360"></a>
            <div class="polaroid-caption">Browser Plugin for Jira Management</div>
        </div></div>
<div class="glass-card" style="position: relative; overflow: hidden;"><h3><span class="highlight">MarkDeck</span></h3>
<div class="polaroid-image" style="text-align:center;">
            <img src="https://github.com/sarivoli/common/blob/6b3406733b220663103c9b7d0c9700def4274e9d/markdeck/logo.png?raw=true" alt="MARKDECK">
            <div class="polaroid-caption">Visual Studio Code extension</div>
        </div></div></div>
                </div>
            </div>
        

            <div class="slide" id="slide-14" data-transition="fade">
                <div class="slide-content">
                    <div class="grid-container"><div class="glass-card" style="flex: 3; position: relative; overflow: hidden;"><div class="polaroid-image" style="text-align:center;">
            <img src="https://github.com/sarivoli/common/blob/8c31a8aeb9a5cba214fa94c8fdaec86e5eb2636f/arivoli-in-logo.png?raw=true" alt="arivoli.in">
            <div class="polaroid-caption">Thank You !!</div>
        </div></div>
<div class="glass-card" style="flex: 7; position: relative; overflow: hidden;"><h1>To Connect:</h1>
<h2><span class="badge"><span class="badge-label">visit</span><span class="badge-value"><a href="http://www.arivoli.in">www.arivoli.in</a></span></span></h2>
<h1>To Download:</h1>
<h2><span class="badge"><span class="badge-label">VisualStudio]</span><span class="badge-value"><a href="https://marketplace.visualstudio.com/publishers/arivoli-in">https://marketplace.visualstudio.com/publishers/arivoli-in</a></span></span></h2>
<h2><span class="badge"><span class="badge-label">OpenVSX]</span><span class="badge-value"><a href="https://open-vsx.org/extension/arivoli-in">https://open-vsx.org/extension/arivoli-in</a></span></span></h2>
</div></div>
                </div>
            </div>
        
    </div>

    <!-- Navigation -->
    <div class="nav-bar">
        <button class="btn-nav" onclick="prevSlide()">‚óÑ Prev</button>
        <div class="progress-track"><div class="progress-fill" id="progress"></div></div>
        <button class="btn-nav" onclick="nextSlide()">Next ‚ñ∫</button>
    </div>
    
    <!-- Status Bar -->
    <div id="status-bar" class="status-bar">Loading...</div>

    <script>
        // Theme JS
        // NeonNights Theme Script
console.log('NeonNights theme loaded');

        
        // Navigation Logic
        let currentSlideIndex = 0;
        const slides = document.querySelectorAll('.slide');
        const statusBar = document.getElementById('status-bar');
        
        // Use titles from metadata
        const slideTitles = ["MARKDECK","Lists & Headings","Cards, Grids, Animation & Themes","Data Visualization","Grid with Flex Ratios","Percentage-Based Grid Layout","Complex Layout with Multiple Ratios","Quote, Info & Warning Blocks","CountUp & CountDown Widgets","Meter Widget (Speedometer Style)","Progress Bar Widgets","Flip Cards - Interactive Content","Combining Multiple Features","More Tools from [[Author:Arivoli]] !","To Connect:"];

        function applySlideAnimation(slide) {
            const slideAnim = slide.getAttribute('data-slide-animation');
            if (slideAnim && typeof AnimationManager !== 'undefined' && AnimationManager.animations[slideAnim]) {
                // Create or get canvas for slide animation
                let canvas = slide.querySelector('canvas.slide-animation-canvas');
                if (!canvas) {
                    canvas = document.createElement('canvas');
                    canvas.className = 'slide-animation-canvas';
                    canvas.style.position = 'absolute';
                    canvas.style.top = '0';
                    canvas.style.left = '0';
                    canvas.style.width = '100%';
                    canvas.style.height = '100%';
                    canvas.style.zIndex = '1';
                    canvas.style.pointerEvents = 'none';
                    slide.style.position = 'relative';
                    slide.appendChild(canvas);
                }
                
                // Set canvas dimensions
                canvas.width = slide.clientWidth;
                canvas.height = slide.clientHeight;
                
                AnimationManager.start(slideAnim, canvas, {});
            }
        }

        function triggerSlideWidgets(slide) {
            // Re-trigger countup widgets
            slide.querySelectorAll('.countup-widget').forEach(widget => {
                const target = parseInt(widget.getAttribute('data-target')) || 0;
                const prefix = widget.getAttribute('data-prefix') || '';
                const suffix = widget.getAttribute('data-suffix') || '';
                const duration = parseInt(widget.getAttribute('data-duration')) || 2000;
                animateCount(widget, 0, target, duration, prefix, suffix);
            });
            
            // Re-trigger countdown widgets
            slide.querySelectorAll('.countdown-widget').forEach(widget => {
                const target = parseInt(widget.getAttribute('data-target')) || 0;
                const start = parseInt(widget.getAttribute('data-start')) || 100;
                const prefix = widget.getAttribute('data-prefix') || '';
                const suffix = widget.getAttribute('data-suffix') || '';
                const duration = parseInt(widget.getAttribute('data-duration')) || 2000;
                animateCount(widget, start, target, duration, prefix, suffix);
            });
            
            // Re-trigger meter widgets
            slide.querySelectorAll('.meter-widget').forEach(widget => {
                const display = widget.querySelector('.meter-display');
                const needle = widget.querySelector('.meter-needle');
                const target = parseInt(widget.getAttribute('data-target')) || 0;
                if (display && needle) {
                    animateMeter(display, needle, target);
                }
            });
            
            // Re-trigger progress bars
            slide.querySelectorAll('.progress-widget').forEach(widget => {
                const label = widget.querySelector('.progress-label');
                const fill = widget.querySelector('.progress-bar-fill');
                const target = parseInt(widget.getAttribute('data-target')) || 0;
                const color = widget.getAttribute('data-color') || 'blue';
                const prefix = widget.getAttribute('data-prefix') || '';
                const suffix = widget.getAttribute('data-suffix') || '';
                const showRatio = widget.getAttribute('data-ratio') === 'true';
                
                if (label && fill) {
                    // Reset first
                    fill.style.width = '0%';
                    setTimeout(() => {
                        animateProgress(label, fill, target, prefix, suffix, showRatio);
                    }, 50);
                }
            });
        }

        function showSlide(index) {
            if (index < 0) index = slides.length - 1;
            if (index >= slides.length) index = 0;
            
            slides.forEach(s => s.classList.remove('active'));
            slides[index].classList.add('active');
            
            const content = slides[index].querySelector('.slide-content');
            if(content) {
                content.scrollTop = 0;
                content.style.animation = 'none';
                content.offsetHeight; 
                content.style.animation = 'slideUp 0.6s cubic-bezier(0.16, 1, 0.3, 1)';
            }
            
            if (statusBar) {
                const currentTitle = slideTitles[index];
                const nextIndex = (index + 1) % slides.length;
                const nextTitle = slideTitles[nextIndex];
                statusBar.innerText = `${index + 1} / ${slides.length} : ${currentTitle}  |  Next: ${nextTitle}`;
            }
            
            currentSlideIndex = index;
            
            // Apply slide-specific animation
            setTimeout(() => {
                applySlideAnimation(slides[index]);
            }, 100);
            
            triggerSlideWidgets(slides[index]);
            updateProgress();
        }

        function nextSlide() { showSlide(currentSlideIndex + 1); }
        function prevSlide() { showSlide(currentSlideIndex - 1); }
        function updateProgress() {
            const p = document.getElementById('progress');
            if(p) p.style.width = ((currentSlideIndex + 1) / slides.length * 100) + '%';
        }

        // Initialize with first slide
        showSlide(0);
        
        
        
        const nav = document.querySelector('.nav-bar');
        document.querySelectorAll('.slide-content').forEach(content => {
            content.addEventListener('mouseenter', () => nav.classList.add('visible'));
            content.addEventListener('mouseleave', () => nav.classList.remove('visible'));
        });
    </script>
    
    
        <script>
            document.addEventListener('DOMContentLoaded', () => {
                const widgets = document.querySelectorAll('.slide-widget');
                widgets.forEach((widget, index) => {
                    try {
                        let configStr = widget.getAttribute('data-config');
                        configStr = configStr.replace(/&apos;/g, "'");
                        const userConfig = JSON.parse(configStr);
                        
                        const canvas = document.createElement('canvas');
                        
                        // Use user-defined styling or defaults
                        widget.style.backgroundColor = userConfig.backgroundColor || 'rgba(248, 249, 250, 1)';
                        widget.style.border = userConfig.border || '5px solid #ccc';
                        widget.style.borderRadius = userConfig.borderRadius || '12px';
                        widget.style.padding = userConfig.padding || '0';
                        canvas.style.padding = userConfig.canvasPadding || '30px';
                        
                        const width = widget.getAttribute('data-width');
                        const height = widget.getAttribute('data-height');
                        
                        if (width) {
                            canvas.width = parseInt(width);
                            canvas.style.width = width + 'px';
                        }
                        if (height) {
                            canvas.height = parseInt(height);
                            canvas.style.height = height + 'px';
                        }
                        
                        widget.appendChild(canvas);
                        
                        // Build chart options - merge user config with defaults
                        const chartOptions = {
                            responsive: userConfig.responsive !== undefined ? userConfig.responsive : (!width && !height),
                            maintainAspectRatio: userConfig.maintainAspectRatio !== undefined ? userConfig.maintainAspectRatio : (!width && !height),
                            plugins: {
                                legend: userConfig.legend || { display: true },
                                title: { 
                                    display: !!userConfig.title, 
                                    text: userConfig.title || '',
                                    font: userConfig.titleFont || { size: 16, weight: 'bold' },
                                    color: userConfig.titleColor || '#333'
                                },
                                tooltip: {
                                    enabled: userConfig.tooltipEnabled !== undefined ? userConfig.tooltipEnabled : true,
                                    backgroundColor: userConfig.tooltipBgColor || 'rgba(0,0,0,0.8)',
                                    titleFont: userConfig.tooltipTitleFont || { size: 14 },
                                    bodyFont: userConfig.tooltipBodyFont || { size: 12 },
                                    titleColor: userConfig.tooltipTitleColor || '#fff',
                                    bodyColor: userConfig.tooltipBodyColor || '#fff'
                                }
                            },
                            ...(userConfig.options || {})
                        };
                        
                        // Add scales if not in user options and chart type supports it
                        const chartType = userConfig.type === 'barchart' ? 'bar' : userConfig.type;
                        if (!userConfig.options?.scales && ['bar', 'line', 'scatter', 'bubble'].includes(chartType)) {
                            chartOptions.scales = {
                                y: { 
                                    beginAtZero: userConfig.yBeginAtZero !== undefined ? userConfig.yBeginAtZero : true,
                                    grid: { 
                                        color: userConfig.yGridColor || 'rgba(0,0,0,0.1)',
                                        display: userConfig.yGridDisplay !== undefined ? userConfig.yGridDisplay : true
                                    },
                                    ticks: {
                                        color: userConfig.yTickColor || '#666',
                                        font: userConfig.yTickFont || { size: 12 }
                                    },
                                    title: {
                                        display: !!userConfig.yAxisTitle,
                                        text: userConfig.yAxisTitle || '',
                                        color: userConfig.yAxisTitleColor || '#333',
                                        font: userConfig.yAxisTitleFont || { size: 14, weight: 'bold' }
                                    }
                                },
                                x: { 
                                    grid: { 
                                        display: userConfig.xGridDisplay !== undefined ? userConfig.xGridDisplay : false,
                                        color: userConfig.xGridColor || 'rgba(0,0,0,0.1)'
                                    },
                                    ticks: {
                                        color: userConfig.xTickColor || '#666',
                                        font: userConfig.xTickFont || { size: 12 }
                                    },
                                    title: {
                                        display: !!userConfig.xAxisTitle,
                                        text: userConfig.xAxisTitle || '',
                                        color: userConfig.xAxisTitleColor || '#333',
                                        font: userConfig.xAxisTitleFont || { size: 14, weight: 'bold' }
                                    }
                                }
                            };
                        }
                        
                        new Chart(canvas, {
                            type: chartType,
                            data: userConfig.data,
                            options: chartOptions
                        });
                    } catch(e) {
                        console.error('Widget render error', e);
                        widget.innerHTML = 'Error loading Chart: ' + e.message;
                    }
                });
            });
        </script>
    
    
    <script>
    const AnimationManager = {
        ensureCanvasDimensions: function(canvas) {
            const parent = canvas.parentElement;
            let width = parent.clientWidth;
            let height = parent.clientHeight;
            if (width === 0 || height === 0) {
                width = 300; height = 200;
            }
            canvas.width = width;
            canvas.height = height;
            return { width, height };
        },
        animations: {},
        registerAnimation: function(name, animationFn) {
            this.animations[name] = animationFn;
        },
        start: function(name, canvas, colors) {
            if (this.animations[name]) {
                this.animations[name](canvas, colors || {});
            } else {
                console.warn('Animation not found:', name);
            }
        },
        initAll: function() {
            const bgCanvas = document.getElementById('bg-canvas');
            const globalAnim = "particles";
            if (bgCanvas && globalAnim !== 'none' && globalAnim !== 'particles') { 
                this.start(globalAnim, bgCanvas, {});
            }
            const elements = document.querySelectorAll('[data-animation]');
            elements.forEach(el => {
                const animName = el.getAttribute('data-animation');
                const colorsStr = el.getAttribute('data-colors');
                let colors = {};
                if (colorsStr) {
                    try { colors = JSON.parse(colorsStr); } catch(e) {}
                }
                let canvas = el.querySelector('canvas.card-bg-canvas');
                if (!canvas) {
                    canvas = document.createElement('canvas');
                    canvas.style.position = 'absolute';
                    canvas.style.top = '0';
                    canvas.style.left = '0';
                    canvas.style.width = '100%';
                    canvas.style.height = '100%';
                    canvas.style.zIndex = '-1';
                    canvas.style.pointerEvents = 'none';
                    el.prepend(canvas);
                    if(getComputedStyle(el).position === 'static') {
                        el.style.position = 'relative'; 
                    }
                }
                this.start(animName, canvas, colors);
            });
        }
    };
    
    (function() {
        /**
 * Celebration Theme Animation
 * Confetti particles with sparkle effects
 * 
 * @param {HTMLCanvasElement} canvas - The canvas element to draw on
 * @param {Object} colors - Color configuration
 * @param {string} colors.color1 - First confetti color (default: #ff6b6b)
 * @param {string} colors.color2 - Second confetti color (default: #4ecdc4)
 * @param {string} colors.color3 - Third confetti color (default: #ffe66d)
 */
function celebrateAnimation(canvas, colors = {}) {
    const ctx = canvas.getContext('2d');
    const color1 = colors.color1 || '#ff6b6b';
    const color2 = colors.color2 || '#4ecdc4';
    const color3 = colors.color3 || '#ffe66d';
    const colorPalette = [color1, color2, color3];
    
    function resize() {
        if (typeof AnimationManager !== 'undefined') {
            AnimationManager.ensureCanvasDimensions(canvas);
        } else {
            canvas.width = canvas.parentElement.clientWidth || 300;
            canvas.height = canvas.parentElement.clientHeight || 200;
        }
    }
    resize();
    window.addEventListener('resize', resize);
    
    const confetti = [];
    for(let i = 0; i < 100; i++) {
        confetti.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height - canvas.height,
            vx: (Math.random() - 0.5) * 2,
            vy: Math.random() * 2 + 1,
            rotation: Math.random() * Math.PI * 2,
            rotationSpeed: (Math.random() - 0.5) * 0.2,
            size: 5 + Math.random() * 10,
            color: colorPalette[Math.floor(Math.random() * colorPalette.length)],
            shape: Math.random() > 0.5 ? 'rect' : 'circle'
        });
    }
    
    function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        confetti.forEach(c => {
            c.x += c.vx;
            c.y += c.vy;
            c.rotation += c.rotationSpeed;
            
            if(c.y > canvas.height) {
                c.y = -20;
                c.x = Math.random() * canvas.width;
            }
            
            ctx.save();
            ctx.translate(c.x, c.y);
            ctx.rotate(c.rotation);
            ctx.fillStyle = c.color;
            
            if(c.shape === 'rect') {
                ctx.fillRect(-c.size/2, -c.size/2, c.size, c.size);
            } else {
                ctx.beginPath();
                ctx.arc(0, 0, c.size/2, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
            
            // Sparkle effect
            if(Math.random() > 0.98) {
                ctx.fillStyle = '#ffffff';
                ctx.globalAlpha = 0.8;
                ctx.beginPath();
                ctx.arc(c.x, c.y, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        });
        
        requestAnimationFrame(animate);
    }
    animate();
}

// Export for Node.js (used by generator)
if (typeof module !== 'undefined' && module.exports) {
    module.exports = celebrateAnimation;
}

        if (typeof celebrateAnimation === 'function') {
            AnimationManager.registerAnimation('celebrate', celebrateAnimation);
        }
    })();
    

    (function() {
        /**
 * Sales & Cost Theme Animation
 * Upward trending arrows with currency symbols
 * 
 * @param {HTMLCanvasElement} canvas - The canvas element to draw on
 * @param {Object} colors - Color configuration
 * @param {string} colors.positive - Upward/growth color (default: #2ecc71)
 * @param {string} colors.negative - Downward/loss color (default: #e74c3c)
 */
function growthAnimation(canvas, colors = {}) {
    const ctx = canvas.getContext('2d');
    const positiveColor = colors.positive || '#2ecc71';
    const negativeColor = colors.negative || '#e74c3c';
    
    function resize() {
        if (typeof AnimationManager !== 'undefined') {
            AnimationManager.ensureCanvasDimensions(canvas);
        } else {
            canvas.width = canvas.parentElement.clientWidth || 300;
            canvas.height = canvas.parentElement.clientHeight || 200;
        }
    }
    resize();
    window.addEventListener('resize', resize);
    
    const arrows = [];
    const symbols = ['$', '‚Ç¨', '¬•', '¬£'];
    
    for(let i = 0; i < 20; i++) {
        arrows.push({
            x: Math.random() * canvas.width,
            y: canvas.height + Math.random() * 100,
            speed: 1 + Math.random() * 2,
            size: 15 + Math.random() * 15,
            isPositive: Math.random() > 0.3,
            symbol: symbols[Math.floor(Math.random() * symbols.length)]
        });
    }
    
    function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        arrows.forEach(arrow => {
            arrow.y -= arrow.speed;
            if(arrow.y < -50) {
                arrow.y = canvas.height + 50;
                arrow.x = Math.random() * canvas.width;
            }
            
            const color = arrow.isPositive ? positiveColor : negativeColor;
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 2;
            
            // Draw arrow
            ctx.beginPath();
            ctx.moveTo(arrow.x, arrow.y);
            ctx.lineTo(arrow.x, arrow.y + arrow.size);
            ctx.stroke();
            
            // Arrow head
            ctx.beginPath();
            ctx.moveTo(arrow.x, arrow.y);
            ctx.lineTo(arrow.x - 5, arrow.y + 10);
            ctx.lineTo(arrow.x + 5, arrow.y + 10);
            ctx.closePath();
            ctx.fill();
            
            // Currency symbol
            ctx.font = '16px Arial';
            ctx.globalAlpha = 0.5;
            ctx.fillText(arrow.symbol, arrow.x + 15, arrow.y + arrow.size/2);
            ctx.globalAlpha = 1;
        });
        
        requestAnimationFrame(animate);
    }
    animate();
}

// Export for Node.js (used by generator)
if (typeof module !== 'undefined' && module.exports) {
    module.exports = growthAnimation;
}

        if (typeof growthAnimation === 'function') {
            AnimationManager.registerAnimation('growth', growthAnimation);
        }
    })();
    

    (function() {
        /**
 * Initiative Theme Animation
 * Forward-moving arrows with progress waves
 * 
 * @param {HTMLCanvasElement} canvas - The canvas element to draw on
 * @param {Object} colors - Color configuration
 * @param {string} colors.primary - Main arrow/wave color (default: #3498db)
 * @param {string} colors.secondary - Alternate wave color (default: #9b59b6)
 */
function initiativeAnimation(canvas, colors = {}) {
    const ctx = canvas.getContext('2d');
    const primaryColor = colors.primary || '#3498db';
    const secondaryColor = colors.secondary || '#9b59b6';
    
    function resize() {
        if (typeof AnimationManager !== 'undefined') {
            AnimationManager.ensureCanvasDimensions(canvas);
        } else {
            canvas.width = canvas.parentElement.clientWidth || 300;
            canvas.height = canvas.parentElement.clientHeight || 200;
        }
    }
    resize();
    window.addEventListener('resize', resize);
    
    const waves = [];
    for(let i = 0; i < 3; i++) {
        waves.push({
            offset: i * 100,
            speed: 2 + i * 0.5,
            amplitude: 30 + i * 10,
            color: i % 2 === 0 ? primaryColor : secondaryColor
        });
    }
    
    const arrows = [];
    for(let i = 0; i < 10; i++) {
        arrows.push({
            x: -50 + Math.random() * 100,
            y: Math.random() * canvas.height,
            speed: 2 + Math.random() * 2,
            size: 20 + Math.random() * 20
        });
    }
    
    function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw progress waves
        waves.forEach(wave => {
            wave.offset += wave.speed;
            if(wave.offset > canvas.width) wave.offset = 0;
            
            ctx.strokeStyle = wave.color;
            ctx.globalAlpha = 0.3;
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            for(let x = 0; x < canvas.width; x += 5) {
                const y = canvas.height/2 + Math.sin((x + wave.offset) * 0.01) * wave.amplitude;
                if(x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.globalAlpha = 1;
        });
        
        // Draw forward arrows
        arrows.forEach(arrow => {
            arrow.x += arrow.speed;
            if(arrow.x > canvas.width + 50) {
                arrow.x = -50;
                arrow.y = Math.random() * canvas.height;
            }
            
            ctx.fillStyle = primaryColor;
            ctx.globalAlpha = 0.6;
            
            // Arrow body
            ctx.fillRect(arrow.x, arrow.y - 3, arrow.size, 6);
            
            // Arrow head
            ctx.beginPath();
            ctx.moveTo(arrow.x + arrow.size, arrow.y);
            ctx.lineTo(arrow.x + arrow.size - 10, arrow.y - 8);
            ctx.lineTo(arrow.x + arrow.size - 10, arrow.y + 8);
            ctx.closePath();
            ctx.fill();
            ctx.globalAlpha = 1;
        });
        
        requestAnimationFrame(animate);
    }
    animate();
}

// Export for Node.js (used by generator)
if (typeof module !== 'undefined' && module.exports) {
    module.exports = initiativeAnimation;
}

        if (typeof initiativeAnimation === 'function') {
            AnimationManager.registerAnimation('initiative', initiativeAnimation);
        }
    })();
    

    (function() {
        /**
 * Network/Constellation Animation
 * Creates a particle network with connecting lines
 * 
 * @param {HTMLCanvasElement} canvas - The canvas element to draw on
 * @param {Object} colors - Color configuration (not used in this animation)
 */
function netAnimation(canvas, colors = {}) {
    const ctx = canvas.getContext('2d');
    let particles = [];
    const count = 50;
    
    function resize() {
        if (typeof AnimationManager !== 'undefined') {
            AnimationManager.ensureCanvasDimensions(canvas);
        } else {
            canvas.width = canvas.parentElement.clientWidth || 300;
            canvas.height = canvas.parentElement.clientHeight || 200;
        }
    }
    resize();
    window.addEventListener('resize', resize);
    
    // Init Particles
    for(let i=0; i<count; i++) {
        particles.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            vx: (Math.random() - 0.5) * 1,
            vy: (Math.random() - 0.5) * 1,
            size: Math.random() * 3
        });
    }
    
    function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Update & Draw Nodes
        ctx.fillStyle = '#fafafaff';
        particles.forEach(p => {
            p.x += p.vx; p.y += p.vy;
            if(p.x < 0 || p.x > canvas.width) p.vx *= -1;
            if(p.y < 0 || p.y > canvas.height) p.vy *= -1;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
            ctx.fill();
        });
        
        // Draw Connections
        ctx.strokeStyle = 'rgba(56, 189, 248, 0.15)';
        ctx.lineWidth = 1;
        for(let i=0; i<particles.length; i++) {
            for(let j=i+1; j<particles.length; j++) {
                const dx = particles[i].x - particles[j].x;
                const dy = particles[i].y - particles[j].y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if(dist < 150) {
                    ctx.beginPath();
                    ctx.moveTo(particles[i].x, particles[i].y);
                    ctx.lineTo(particles[j].x, particles[j].y);
                    ctx.globalAlpha = 1 - (dist/150);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
            }
        }
        requestAnimationFrame(animate);
    }
    animate();
}

// Export for Node.js (used by generator)
if (typeof module !== 'undefined' && module.exports) {
    module.exports = netAnimation;
}

        if (typeof netAnimation === 'function') {
            AnimationManager.registerAnimation('net', netAnimation);
        }
    })();
    

    (function() {
        /**
 * Cybersecurity Theme Animation
 * Binary code rain with floating shield icons
 * 
 * @param {HTMLCanvasElement} canvas - The canvas element to draw on
 * @param {Object} colors - Color configuration
 * @param {string} colors.primary - Binary code color (default: #00ff00)
 * @param {string} colors.accent - Shield outline color (default: #00aa00)
 */
function securityAnimation(canvas, colors = {}) {
    const ctx = canvas.getContext('2d');
    const primaryColor = colors.primary || '#00ff00';
    const accentColor = colors.accent || '#00aa00';
    
    function resize() {
        if (typeof AnimationManager !== 'undefined') {
            AnimationManager.ensureCanvasDimensions(canvas);
        } else {
            canvas.width = canvas.parentElement.clientWidth || 300;
            canvas.height = canvas.parentElement.clientHeight || 200;
        }
    }
    resize();
    window.addEventListener('resize', resize);
    
    // Binary code streams
    const streams = [];
    const streamCount = Math.floor(canvas.width / 20);
    for(let i = 0; i < streamCount; i++) {
        streams.push({
            x: i * 20,
            y: Math.random() * canvas.height,
            speed: 1 + Math.random() * 2,
            chars: '01'
        });
    }
    
    // Shield icons
    const shields = [];
    for(let i = 0; i < 5; i++) {
        shields.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            vx: (Math.random() - 0.5) * 0.5,
            vy: (Math.random() - 0.5) * 0.5,
            size: 20 + Math.random() * 20
        });
    }
    
    function animate() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw binary streams
        ctx.font = '14px monospace';
        ctx.fillStyle = primaryColor;
        streams.forEach(s => {
            const char = s.chars[Math.floor(Math.random() * 2)];
            ctx.fillText(char, s.x, s.y);
            s.y += s.speed;
            if(s.y > canvas.height) s.y = 0;
        });
        
        // Draw shields
        shields.forEach(shield => {
            shield.x += shield.vx;
            shield.y += shield.vy;
            if(shield.x < 0 || shield.x > canvas.width) shield.vx *= -1;
            if(shield.y < 0 || shield.y > canvas.height) shield.vy *= -1;
            
            ctx.strokeStyle = accentColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            // Draw shield shape
            ctx.moveTo(shield.x, shield.y - shield.size/2);
            ctx.lineTo(shield.x + shield.size/2, shield.y);
            ctx.lineTo(shield.x, shield.y + shield.size/2);
            ctx.lineTo(shield.x - shield.size/2, shield.y);
            ctx.closePath();
            ctx.stroke();
        });
        
        requestAnimationFrame(animate);
    }
    animate();
}

// Export for Node.js (used by generator)
if (typeof module !== 'undefined' && module.exports) {
    module.exports = securityAnimation;
}

        if (typeof securityAnimation === 'function') {
            AnimationManager.registerAnimation('security', securityAnimation);
        }
    })();
    

    (function() {
        /**
 * Framework Change Theme Animation
 * Morphing geometric shapes that transition between forms and colors
 * 
 * @param {HTMLCanvasElement} canvas - The canvas element to draw on
 * @param {Object} colors - Color configuration
 * @param {string} colors.from - Starting color (default: #ff6b6b)
 * @param {string} colors.to - Ending color (default: #4ecdc4)
 */
function transformAnimation(canvas, colors = {}) {
    const ctx = canvas.getContext('2d');
    const fromColor = colors.from || '#ff6b6b';
    const toColor = colors.to || '#4ecdc4';
    
    function resize() {
        if (typeof AnimationManager !== 'undefined') {
            AnimationManager.ensureCanvasDimensions(canvas);
        } else {
            canvas.width = canvas.parentElement.clientWidth || 300;
            canvas.height = canvas.parentElement.clientHeight || 200;
        }
    }
    resize();
    window.addEventListener('resize', resize);
    
    const shapes = [];
    for(let i = 0; i < 15; i++) {
        shapes.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            size: 20 + Math.random() * 40,
            rotation: Math.random() * Math.PI * 2,
            rotationSpeed: (Math.random() - 0.5) * 0.02,
            morphProgress: Math.random(),
            morphSpeed: 0.005 + Math.random() * 0.01,
            vx: (Math.random() - 0.5) * 0.5,
            vy: (Math.random() - 0.5) * 0.5
        });
    }
    
    function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        shapes.forEach(shape => {
            shape.x += shape.vx;
            shape.y += shape.vy;
            shape.rotation += shape.rotationSpeed;
            shape.morphProgress += shape.morphSpeed;
            if(shape.morphProgress > 1) shape.morphProgress = 0;
            
            if(shape.x < 0 || shape.x > canvas.width) shape.vx *= -1;
            if(shape.y < 0 || shape.y > canvas.height) shape.vy *= -1;
            
            ctx.save();
            ctx.translate(shape.x, shape.y);
            ctx.rotate(shape.rotation);
            
            // Interpolate color
            const progress = shape.morphProgress;
            const r1 = parseInt(fromColor.slice(1,3), 16);
            const g1 = parseInt(fromColor.slice(3,5), 16);
            const b1 = parseInt(fromColor.slice(5,7), 16);
            const r2 = parseInt(toColor.slice(1,3), 16);
            const g2 = parseInt(toColor.slice(3,5), 16);
            const b2 = parseInt(toColor.slice(5,7), 16);
            
            const r = Math.floor(r1 + (r2 - r1) * progress);
            const g = Math.floor(g1 + (g2 - g1) * progress);
            const b = Math.floor(b1 + (b2 - b1) * progress);
            
            ctx.strokeStyle = 'rgba(' + r + ', ' + g + ', ' + b + ', 0.6)';
            ctx.lineWidth = 2;
            
            // Morph between square and circle
            ctx.beginPath();
            if(progress < 0.5) {
                // Square
                ctx.rect(-shape.size/2, -shape.size/2, shape.size, shape.size);
            } else {
                // Circle
                ctx.arc(0, 0, shape.size/2, 0, Math.PI * 2);
            }
            ctx.stroke();
            ctx.restore();
        });
        
        requestAnimationFrame(animate);
    }
    animate();
}

// Export for Node.js (used by generator)
if (typeof module !== 'undefined' && module.exports) {
    module.exports = transformAnimation;
}

        if (typeof transformAnimation === 'function') {
            AnimationManager.registerAnimation('transform', transformAnimation);
        }
    })();
    
    document.addEventListener('DOMContentLoaded', () => {
        requestAnimationFrame(() => {
            AnimationManager.initAll();
        });
    });
    </script>
    
    
    <!-- Widget Animations -->
    <script>
        // Widget Initialization Script
document.addEventListener('DOMContentLoaded', () => {
    initCountWidgets();
    initMeterWidgets();
    initProgressWidgets();
    initFlipCards();
});

// CountUp Widget
function initCountWidgets() {
    // CountUp
    document.querySelectorAll('.countup-widget').forEach(widget => {
        const target = parseInt(widget.getAttribute('data-target')) || 0;
        const prefix = widget.getAttribute('data-prefix') || '';
        const suffix = widget.getAttribute('data-suffix') || '';
        const duration = parseInt(widget.getAttribute('data-duration')) || 2000;
        
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    animateCount(widget, 0, target, duration, prefix, suffix);
                    observer.unobserve(widget);
                }
            });
        }, { threshold: 0.5 });
        
        observer.observe(widget);
    });
    
    // CountDown
    document.querySelectorAll('.countdown-widget').forEach(widget => {
        const target = parseInt(widget.getAttribute('data-target')) || 0;
        const start = parseInt(widget.getAttribute('data-start')) || 100;
        const prefix = widget.getAttribute('data-prefix') || '';
        const suffix = widget.getAttribute('data-suffix') || '';
        const duration = parseInt(widget.getAttribute('data-duration')) || 2000;
        
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    animateCount(widget, start, target, duration, prefix, suffix);
                    observer.unobserve(widget);
                }
            });
        }, { threshold: 0.5 });
        
        observer.observe(widget);
    });
}

function animateCount(element, start, end, duration, prefix, suffix) {
    const startTime = performance.now();
    const isCountDown = start > end;
    
    function update(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Easing function for smooth animation
        const easeOutQuart = 1 - Math.pow(1 - progress, 4);
        
        const current = Math.floor(start + (end - start) * easeOutQuart);
        element.textContent = `${prefix}${current}${suffix}`;
        
        if (progress < 1) {
            requestAnimationFrame(update);
        } else {
            element.textContent = `${prefix}${end}${suffix}`;
        }
    }
    
    requestAnimationFrame(update);
}

// Meter Widget (Speedometer Style)
function initMeterWidgets() {
    document.querySelectorAll('.meter-widget').forEach(widget => {
        const target = parseInt(widget.getAttribute('data-target')) || 0;
        const green = parseInt(widget.getAttribute('data-green')) || 70;
        const yellow = parseInt(widget.getAttribute('data-yellow')) || 50;
        const red = parseInt(widget.getAttribute('data-red')) || 30;
        
        // Create meter structure
        const display = document.createElement('div');
        display.className = 'meter-display';
        display.textContent = '0';
        
        const gauge = document.createElement('div');
        gauge.className = 'meter-gauge';
        
        // Calculate bar widths
        const totalRange = 100;
        const redWidth = (red / totalRange) * 100;
        const yellowWidth = ((yellow - red) / totalRange) * 100;
        const greenWidth = ((100 - yellow) / totalRange) * 100;
        
        gauge.innerHTML = `
            <div class="meter-bar red" style="width: ${redWidth}%; left: 0;"></div>
            <div class="meter-bar yellow" style="width: ${yellowWidth}%; left: ${redWidth}%;"></div>
            <div class="meter-bar green" style="width: ${greenWidth}%; left: ${redWidth + yellowWidth}%;"></div>
            <div class="meter-needle"></div>
        `;
        
        const labels = document.createElement('div');
        labels.className = 'meter-labels';
        labels.innerHTML = `
            <span>0</span>
            <span>${red}</span>
            <span>${yellow}</span>
            <span>${green}</span>
            <span>100</span>
        `;
        
        widget.appendChild(display);
        widget.appendChild(gauge);
        widget.appendChild(labels);
        
        const needle = gauge.querySelector('.meter-needle');
        
        // Animate when visible
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    animateMeter(display, needle, target);
                    observer.unobserve(widget);
                }
            });
        }, { threshold: 0.5 });
        
        observer.observe(widget);
    });
}

function animateMeter(display, needle, target) {
    const duration = 2000;
    const startTime = performance.now();
    
    function update(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        const easeOutQuart = 1 - Math.pow(1 - progress, 4);
        const current = Math.floor(target * easeOutQuart);
        
        display.textContent = current;
        
        // Rotate needle: -90deg (0%) to 90deg (100%)
        const angle = -90 + (current / 100) * 180;
        needle.style.transform = `rotate(${angle}deg)`;
        
        if (progress < 1) {
            requestAnimationFrame(update);
        } else {
            display.textContent = target;
            needle.style.transform = `rotate(${-90 + (target / 100) * 180}deg)`;
        }
    }
    
    requestAnimationFrame(update);
}

// Progress Bar Widget
function initProgressWidgets() {
    document.querySelectorAll('.progress-widget').forEach(widget => {
        const target = parseInt(widget.getAttribute('data-target')) || 0;
        const color = widget.getAttribute('data-color') || 'blue';
        const prefix = widget.getAttribute('data-prefix') || '';
        const suffix = widget.getAttribute('data-suffix') || '';
        const showRatio = widget.getAttribute('data-ratio') === 'true';
        
        // Create progress bar structure
        const label = document.createElement('div');
        label.className = 'progress-label';
        
        const container = document.createElement('div');
        container.className = 'progress-bar-container';
        
        const fill = document.createElement('div');
        fill.className = `progress-bar-fill ${color}`;
        
        container.appendChild(fill);
        widget.appendChild(label);
        widget.appendChild(container);
        
        // Animate when visible
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    animateProgress(label, fill, target, prefix, suffix, showRatio);
                    observer.unobserve(widget);
                }
            });
        }, { threshold: 0.5 });
        
        observer.observe(widget);
    });
}

function animateProgress(label, fill, target, prefix, suffix, showRatio) {
    const duration = 2000;
    const startTime = performance.now();
    
    function update(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        const easeOutQuart = 1 - Math.pow(1 - progress, 4);
        const current = Math.floor(target * easeOutQuart);
        
        fill.style.width = `${current}%`;
        
        if (showRatio) {
            label.textContent = `${prefix}${current}/100${suffix}`;
        } else {
            label.textContent = `${prefix}${current}%${suffix}`;
        }
        
        if (progress < 1) {
            requestAnimationFrame(update);
        } else {
            fill.style.width = `${target}%`;
            if (showRatio) {
                label.textContent = `${prefix}${target}/100${suffix}`;
            } else {
                label.textContent = `${prefix}${target}%${suffix}`;
            }
        }
    }
    
    requestAnimationFrame(update);
}

// Flip Cards
function initFlipCards() {
    document.querySelectorAll('.flip-card').forEach(card => {
        const autoFlip = card.getAttribute('data-auto') === 'true';
        const flipCount = parseInt(card.getAttribute('data-count')) || 3;
        const flipDelay = parseInt(card.getAttribute('data-delay')) || 2000;
        
        // Manual flip on click
        card.addEventListener('click', () => {
            card.classList.toggle('flipped');
        });
        
        // Auto flip
        if (autoFlip) {
            let count = 0;
            const flipInterval = setInterval(() => {
                card.classList.toggle('flipped');
                count++;
                
                if (count >= flipCount * 2) {
                    clearInterval(flipInterval);
                    // Ensure it ends on the back
                    if (!card.classList.contains('flipped')) {
                        card.classList.add('flipped');
                    }
                }
            }, flipDelay);
        }
    });
}

// Add click-to-animate functionality
document.addEventListener('DOMContentLoaded', () => {
    // Make meters clickable
    document.addEventListener('click', (e) => {
        const meterWidget = e.target.closest('.meter-widget');
        if (meterWidget) {
            const display = meterWidget.querySelector('.meter-display');
            const needle = meterWidget.querySelector('.meter-needle');
            const target = parseInt(meterWidget.getAttribute('data-target')) || 0;
            
            if (display && needle) {
                // Reset
                display.textContent = '0';
                needle.style.transform = 'rotate(-90deg)';
                
                // Animate after brief delay
                setTimeout(() => {
                    animateMeter(display, needle, target);
                }, 50);
            }
        }
        
        // Make progress bars clickable
        const progressWidget = e.target.closest('.progress-widget');
        if (progressWidget) {
            const label = progressWidget.querySelector('.progress-label');
            const fill = progressWidget.querySelector('.progress-bar-fill');
            const target = parseInt(progressWidget.getAttribute('data-target')) || 0;
            const prefix = progressWidget.getAttribute('data-prefix') || '';
            const suffix = progressWidget.getAttribute('data-suffix') || '';
            const showRatio = progressWidget.getAttribute('data-ratio') === 'true';
            
            if (label && fill) {
                // Reset
                fill.style.width = '0%';
                if (showRatio) {
                    label.textContent = `${prefix}0/100${suffix}`;
                } else {
                    label.textContent = `${prefix}0%${suffix}`;
                }
                
                // Animate after brief delay
                setTimeout(() => {
                    animateProgress(label, fill, target, prefix, suffix, showRatio);
                }, 50);
            }
        }
        
        // Make count widgets clickable
        const countWidget = e.target.closest('.countup-widget, .countdown-widget');
        if (countWidget) {
            const isCountdown = countWidget.classList.contains('countdown-widget');
            const target = parseInt(countWidget.getAttribute('data-target')) || 0;
            const start = isCountdown ? parseInt(countWidget.getAttribute('data-start')) || 100 : 0;
            const prefix = countWidget.getAttribute('data-prefix') || '';
            const suffix = countWidget.getAttribute('data-suffix') || '';
            const duration = parseInt(countWidget.getAttribute('data-duration')) || 2000;
            
            animateCount(countWidget, start, target, duration, prefix, suffix);
        }
    });
});

        // Initialize with first slide
        showSlide(0);

        // Force initial progress update
        setTimeout(() => {
            updateProgress();
        }, 50);

        // Keyboard Nav
        document.addEventListener('keydown', (e) => {
            if(e.key === 'ArrowRight' || e.key === 'Space') nextSlide();
            if(e.key === 'ArrowLeft') prevSlide();
        });

    </script>
</body>
</html>
    